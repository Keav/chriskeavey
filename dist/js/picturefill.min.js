/*! Picturefill - v2.1.0 - 2014-07-25
* http://scottjehl.github.io/picturefill
* Copyright (c) 2014 https://github.com/scottjehl/picturefill/blob/master/Authors.txt; Licensed MIT */
/*! matchMedia() polyfill - Test a CSS media type/query in JS. Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license */
window.matchMedia||(window.matchMedia=function(){"use strict";
// For browsers that support matchMedium api such as IE 9 and webkit
var a=window.styleMedia||window.media;
// For those that don't support matchMedium
if(!a){var b=document.createElement("style"),c=document.getElementsByTagName("script")[0],d=null;b.type="text/css",b.id="matchmediajs-test",c.parentNode.insertBefore(b,c),
// 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers
d="getComputedStyle"in window&&window.getComputedStyle(b,null)||b.currentStyle,a={matchMedium:function(a){var c="@media "+a+"{ #matchmediajs-test { width: 1px; } }";
// Test if media query is true or false
// 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers
return b.styleSheet?b.styleSheet.cssText=c:b.textContent=c,"1px"===d.width}}}return function(b){return{matches:a.matchMedium(b||"all"),media:b||"all"}}}()),/*! Picturefill - Responsive Images that work today.
*  Author: Scott Jehl, Filament Group, 2012 ( new proposal implemented by Shawn Jansepar )
*  License: MIT/GPLv2
*  Spec: http://picture.responsiveimages.org/
*/
function(a,b){
// Enable strict mode
"use strict";function c(a){var b,c,d,f,g,h=a||{};b=h.elements||e.getAllElements();
// Loop through all elements
for(var i=0,j=b.length;j>i;i++)
// if the element has already been evaluated, skip it
// unless `options.force` is set to true ( this, for example,
// is set to true when running `picturefill` on `resize` ).
if(c=b[i],d=c.parentNode,f=void 0,g=void 0,c[e.ns]||(c[e.ns]={}),h.reevaluate||!c[e.ns].evaluated){
// if `img` is in a `picture` element
if("PICTURE"===d.nodeName.toUpperCase()){
// if any sources are pending in this picture due to async type test(s)
// remove the evaluated attr and skip for now ( the pending test will
// rerun picturefill on this element when complete)
if(
// IE9 video workaround
e.removeVideoShim(d),f=e.getMatch(c,d),f===!1)continue}else f=void 0;
// Cache and remove `srcset` if present and we’re going to be doing `picture`/`srcset`/`sizes` polyfilling to it.
("PICTURE"===d.nodeName.toUpperCase()||c.srcset&&!e.srcsetSupported||!e.sizesSupported&&c.srcset&&c.srcset.indexOf("w")>-1)&&e.dodgeSrcset(c),f?(g=e.processSourceSet(f),e.applyBestCandidate(g,c)):(g=e.processSourceSet(c),(void 0===c.srcset||c[e.ns].srcset)&&e.applyBestCandidate(g,c)),
// set evaluated to true to avoid unnecessary reparsing
c[e.ns].evaluated=!0}}/**
	 * Sets up picture polyfill by polling the document and running
	 * the polyfill every 250ms until the document is ready.
	 * Also attaches picturefill on resize
	 */
function d(){c();var d=setInterval(function(){
// When the document has finished loading, stop checking for new images
// https://github.com/ded/domready/blob/master/ready.js#L15
return c(),/^loaded|^i|^c/.test(b.readyState)?void clearInterval(d):void 0},250);if(a.addEventListener){var e;a.addEventListener("resize",function(){a._picturefillWorking||(a._picturefillWorking=!0,a.clearTimeout(e),e=a.setTimeout(function(){c({reevaluate:!0}),a._picturefillWorking=!1},60))},!1)}}
// If picture is supported, well, that's awesome. Let's get outta here...
if(a.HTMLPictureElement)return void(a.picturefill=function(){});
// HTML shim|v it for old IE (IE9 will still need the HTML video tag workaround)
b.createElement("picture");
// local object for method references and testing exposure
var e={};
// namespace
e.ns="picturefill",
// srcset support test
e.srcsetSupported="srcset"in b.createElement("img"),e.sizesSupported=a.HTMLImageElement.sizes,
// just a string trim workaround
e.trim=function(a){return a.trim?a.trim():a.replace(/^\s+|\s+$/g,"")},
// just a string endsWith workaround
e.endsWith=function(a,b){return a.endsWith?a.endsWith(b):-1!==a.indexOf(b,a.length-b.length)},/**
	 * Shortcut method for matchMedia ( for easy overriding in tests )
	 */
e.matchesMedia=function(b){return a.matchMedia&&a.matchMedia(b).matches},/**
	 * Shortcut method for `devicePixelRatio` ( for easy overriding in tests )
	 */
e.getDpr=function(){return a.devicePixelRatio||1},/**
	 * Get width in css pixel value from a "length" value
	 * http://dev.w3.org/csswg/css-values-3/#length-value
	 */
e.getWidthFromLength=function(a){
// If no length was specified, or it is 0 or negative, default to `100vw` (per the spec).
/**
		* If length is specified in  `vw` units, use `%` instead since the div we’re measuring
		* is injected at the top of the document.
		*
		* TODO: maybe we should put this behind a feature test for `vw`?
		*/
// Create a cached element for getting length value widths
// Positioning styles help prevent padding/margin/width on `html` from throwing calculations off.
// Something has gone wrong. `calc()` is in use and unsupported, most likely. Default to `100vw` (`100%`, for broader support.):
return a=a&&(parseFloat(a)>0||a.indexOf("calc(")>-1)?a:"100vw",a=a.replace("vw","%"),e.lengthEl||(e.lengthEl=b.createElement("div"),b.documentElement.insertBefore(e.lengthEl,b.documentElement.firstChild)),e.lengthEl.style.cssText="position: absolute; left: 0; width: "+a+";",e.lengthEl.offsetWidth<=0&&(e.lengthEl.style.cssText="width: 100%;"),e.lengthEl.offsetWidth},
// container of supported mime types that one might need to qualify before using
e.types={},
// Add support for standard mime types.
e.types["image/jpeg"]=!0,e.types["image/gif"]=!0,e.types["image/png"]=!0,
// test svg support
e.types["image/svg+xml"]=b.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image","1.1"),
// test webp support, only when the markup calls for it
e.types["image/webp"]=function(){
// based on Modernizr's lossless img-webp test
// note: asynchronous
var b=new a.Image,d="image/webp";b.onerror=function(){e.types[d]=!1,c()},b.onload=function(){e.types[d]=1===b.width,c()},b.src="data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="},/**
	 * Takes a source element and checks if its type attribute is present and if so, supported
	 * Note: for type tests that require a async logic,
	 * you can define them as a function that'll run only if that type needs to be tested. Just make the test function call picturefill again when it is complete.
	 * see the async webp test above for example
	 */
e.verifyTypeSupport=function(a){var b=a.getAttribute("type");
// if type attribute exists, return test result, otherwise return true
// if type attribute exists, return test result, otherwise return true
// if the type test is a function, run it and return "pending" status. The function will rerun picturefill on pending elements once finished.
return null===b||""===b?!0:"function"==typeof e.types[b]?(e.types[b](),"pending"):e.types[b]},/**
	* Parses an individual `size` and returns the length, and optional media query
	*/
e.parseSize=function(a){var b=/(\([^)]+\))?\s*(.+)/g.exec(a);return{media:b&&b[1],length:b&&b[2]}},/**
	 * Takes a string of sizes and returns the width in pixels as a number
	 */
e.findWidthFromSourceSize=function(a){for(var b,c=e.trim(a).split(/\s*,\s*/),d=0,f=c.length;f>d;d++){
// Match <media-condition>? length, ie ( min-width: 50em ) 100%
var g=c[d],
// Split "( min-width: 50em ) 100%" into separate strings
h=e.parseSize(g),i=h.length,j=h.media;if(i&&(!j||e.matchesMedia(j))){
// if there is no media query or it matches, choose this as our winning length
// and end algorithm
b=i;break}}
// pass the length to a method that can properly determine length
// in pixels based on these formats: http://dev.w3.org/csswg/css-values-3/#length-value
return e.getWidthFromLength(b)},e.parseSrcset=function(a){for(/**
		* A lot of this was pulled from Boris Smus’ parser for the now-defunct WHATWG `srcset`
		* https://github.com/borismus/srcset-polyfill/blob/master/js/srcset-info.js
		*
		* 1. Let input (`srcset`) be the value passed to this algorithm.
		* 2. Let position be a pointer into input, initially pointing at the start of the string.
		* 3. Let raw candidates be an initially empty ordered list of URLs with associated 
		*    unparsed descriptors. The order of entries in the list is the order in which entries 
		*    are added to the list.
		*/
var b=[];""!==a;){a=a.replace(/^\s+/g,"");
// 5. Collect a sequence of characters that are not space characters, and let that be url.
var c,d=a.search(/\s/g),e=null;if(-1!==d){c=a.slice(0,d);var f=c[c.length-1];
// 6.2. Collect a sequence of characters that are not U+002C COMMA characters (,), and 
// let that be descriptors.
if(
// 6. If url ends with a U+002C COMMA character (,), remove that character from url
// and let descriptors be the empty string. Otherwise, follow these substeps
// 6.1. If url is empty, then jump to the step labeled descriptor parser.
(","===f||""===c)&&(c=c.replace(/,+$/,""),e=""),a=a.slice(d+1),null===e){var g=a.indexOf(",");-1!==g?(e=a.slice(0,g),a=a.slice(g+1)):(e=a,a="")}}else c=a,a="";
// 7. Add url to raw candidates, associated with descriptors.
(c||e)&&b.push({url:c,descriptor:e})}return b},e.parseDescriptor=function(a,b){
// 11. Descriptor parser: Let candidates be an initially empty source set. The order of entries in the list 
// is the order in which entries are added to the list.
var c,d=b||"100vw",f=a&&a.replace(/(^\s+|\s+$)/g,""),g=e.findWidthFromSourceSize(d);if(f)for(var h=f.split(" "),i=h.length+1;i>=0;i--)if(void 0!==h[i]){var j=h[i],k=j&&j.slice(j.length-1);if("h"!==k&&"w"!==k||e.sizesSupported){if("x"===k){var l=j&&parseFloat(j,10);c=l&&!isNaN(l)?l:1}}else c=parseFloat(parseInt(j,10)/g)}return c||1},/**
	 * Takes a srcset in the form of url/
	 * ex. "images/pic-medium.png 1x, images/pic-medium-2x.png 2x" or
	 *     "images/pic-medium.png 400w, images/pic-medium-2x.png 800w" or
	 *     "images/pic-small.png"
	 * Get an array of image candidates in the form of
	 *      {url: "/foo/bar.png", resolution: 1}
	 * where resolution is http://dev.w3.org/csswg/css-values-3/#resolution-value
	 * If sizes is specified, resolution is calculated
	 */
e.getCandidatesFromSourceSet=function(a,b){for(var c=e.parseSrcset(a),d=[],f=0,g=c.length;g>f;f++){var h=c[f];d.push({url:h.url,resolution:e.parseDescriptor(h.descriptor,b)})}return d},/*
	 * if it's an img element and it has a srcset property,
	 * we need to remove the attribute so we can manipulate src
	 * (the property's existence infers native srcset support, and a srcset-supporting browser will prioritize srcset's value over our winning picture candidate)
	 * this moves srcset's value to memory for later use and removes the attr
	 */
e.dodgeSrcset=function(a){a.srcset&&(a[e.ns].srcset=a.srcset,a.removeAttribute("srcset"))},/*
	 * Accept a source or img element and process its srcset and sizes attrs
	 */
e.processSourceSet=function(a){var b=a.getAttribute("srcset"),c=a.getAttribute("sizes"),d=[];
// if it's an img element, use the cached srcset property (defined or not)
return"IMG"===a.nodeName.toUpperCase()&&a[e.ns]&&a[e.ns].srcset&&(b=a[e.ns].srcset),b&&(d=e.getCandidatesFromSourceSet(b,c)),d},e.applyBestCandidate=function(a,b){var c,d,f;a.sort(e.ascendingSort),d=a.length,f=a[d-1];for(var g=0;d>g;g++)if(c=a[g],c.resolution>=e.getDpr()){f=c;break}f&&!e.endsWith(b.src,f.url)&&(b.src=f.url,
// currentSrc attribute and property to match
// http://picture.responsiveimages.org/#the-img-element
b.currentSrc=b.src)},e.ascendingSort=function(a,b){return a.resolution-b.resolution},/*
	 * In IE9, <source> elements get removed if they aren't children of
	 * video elements. Thus, we conditionally wrap source elements
	 * using <!--[if IE 9]><video style="display: none;"><![endif]-->
	 * and must account for that here by moving those source elements
	 * back into the picture element.
	 */
e.removeVideoShim=function(a){var b=a.getElementsByTagName("video");if(b.length){for(var c=b[0],d=c.getElementsByTagName("source");d.length;)a.insertBefore(d[0],c);
// Remove the video element once we're finished removing its children
c.parentNode.removeChild(c)}},/*
	 * Find all `img` elements, and add them to the candidate list if they have
	 * a `picture` parent, a `sizes` attribute in basic `srcset` supporting browsers,
	 * a `srcset` attribute at all, and they haven’t been evaluated already.
	 */
e.getAllElements=function(){for(var a=[],c=b.getElementsByTagName("img"),d=0,f=c.length;f>d;d++){var g=c[d];("PICTURE"===g.parentNode.nodeName.toUpperCase()||null!==g.getAttribute("srcset")||g[e.ns]&&null!==g[e.ns].srcset)&&a.push(g)}return a},e.getMatch=function(a,b){
// Go through each child, and if they have media queries, evaluate them
for(var c,d=b.childNodes,f=0,g=d.length;g>f;f++){var h=d[f];
// ignore non-element nodes
if(1===h.nodeType){
// Hitting the `img` element that started everything stops the search for `sources`.
// If no previous `source` matches, the `img` itself is evaluated later.
if(h===a)return c;
// ignore non-`source` nodes
if("SOURCE"===h.nodeName.toUpperCase()){
// if it's a source element that has the `src` property set, throw a warning in the console
null!==h.getAttribute("src")&&void 0!==typeof console&&console.warn("The `src` attribute is invalid on `picture` `source` element; instead, use `srcset`.");var i=h.getAttribute("media");
// if source does not have a srcset attribute, skip
if(h.getAttribute("srcset")&&(!i||e.matchesMedia(i))){var j=e.verifyTypeSupport(h);if(j===!0){c=h;break}if("pending"===j)return!1}}}}return c},d(),/* expose methods for testing */
c._=e,/* expose picturefill */
"object"==typeof module&&"object"==typeof module.exports?
// CommonJS, just export
module.exports=c:"function"==typeof define&&define.amd?
// AMD support
define(function(){return c}):"object"==typeof a&&(
// If no AMD and we are in the browser, attach to window
a.picturefill=c)}(this,this.document);